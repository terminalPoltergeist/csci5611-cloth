//              ,---------------------------,
//              |  /---------------------\  |
//              | |                       | |
//              | |     Jack Nemitz       | |
//              | |      CSCI 5611        | |
//              | |     Project 02        | |
//              | |     Main program      | |
//              |  \_____________________/  |
//              |___________________________|
//            ,---\_____     []     _______/------,
//          /         /______________\           /|
//        /___________________________________ /  | ___
//        |                                   |   |    )
//        |  _ _ _                 [-------]  |   |   (
//        |  o o o                 [-------]  |  /    _)_
//        |__________________________________ |/     /  /
//    /-------------------------------------/|      ( )/
//  /-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
///-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
//
// The code contained within this file and all supporting files is generated by me,
// from example code given in class (marked as such), or from documentation as appropriate.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Camera camera;
Cloth cloth = new Cloth(20, new PVector(-10,-10,-50), new PVector(10,-10,-50), 1);

void setup() {
  size(600, 600, P3D);
  camera = new Camera();
}

void keyPressed() {
  camera.HandleKeyPressed();
}

void keyReleased() {
  if (key == 'r') {cloth = new Cloth(20, new PVector(-10,-10,-50), new PVector(10,-10,-50), 1);}
  camera.HandleKeyReleased();
}

//Rope rope = new Rope(20, 1, 1, new PVector(0,0,-50), new PVector(20,0,-50));
PVector sphere = new PVector(0,50,-50);

void draw() {
  background(255);
  directionalLight(255,0,255,5,10,-50);
  camera.Update(1.0/frameRate);

  pushMatrix();
  fill(100,100,0);
  translate(sphere.x,sphere.y,sphere.z);
  sphere(5);
  popMatrix();

  // collision detection
  for (int c = 0; c < cloth.ropes.length; c++) {
    // every rope
    for (int m = 0; m < cloth.ropes[c].nodes.length; m++) {
      // every node
      PVector node_pos = cloth.ropes[c].nodes[m].pos;
      float dist = node_pos.dist(sphere);
      float delta = 5 - dist; // how far inside the sphere is the node?
      if (delta >= 0) {
        PVector dir = PVector.sub(node_pos,sphere);
        dir.normalize();
        PVector diff = PVector.mult(dir, delta);
        cloth.ropes[c].nodes[m].pos.add(diff);
        cloth.ropes[c].nodes[m].vel.mult(0.9);
      }
    }
  }

  PImage img = loadImage("lines.jpg");
  textureMode(NORMAL);

  for (int i = 0; i < cloth.ropes.length - 1; i++) {
    Rope curr_rope = cloth.ropes[i];
    Rope next_rope = cloth.ropes[i+1];
    for (int k = 1; k < curr_rope.nodes.length; k++) {
      PVector v1 = curr_rope.nodes[k-1].pos;
      PVector v2 = next_rope.nodes[k-1].pos;
      PVector v3 = next_rope.nodes[k].pos;
      PVector v4 = curr_rope.nodes[k].pos;
      beginShape();
      texture(img);
      noStroke();
      //fill(0,100,100);
      vertex(v1.x, v1.y, v1.z);
      vertex(v2.x, v2.y, v2.z);     
      vertex(v3.x, v3.y, v3.z);
      vertex(v4.x, v4.y, v4.z);
      endShape();
    }
  }

  cloth.update_physics(0.05, 1, 100);
}
