//              ,---------------------------,
//              |  /---------------------\  |
//              | |                       | |
//              | |     Jack Nemitz       | |
//              | |      CSCI 5611        | |
//              | |     Project 02        | |
//              | |     Cloth class       | |
//              |  \_____________________/  |
//              |___________________________|
//            ,---\_____     []     _______/------,
//          /         /______________\           /|
//        /___________________________________ /  | ___
//        |                                   |   |    )
//        |  _ _ _                 [-------]  |   |   (
//        |  o o o                 [-------]  |  /    _)_
//        |__________________________________ |/     /  /
//    /-------------------------------------/|      ( )/
//  /-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
///-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
//
// The code contained within this file and all supporting files is generated by me,
// from example code given in class (marked as such), or from documentation as appropriate.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

PVector g = new PVector(0,9.8,0);

class Cloth {
  public Rope[] ropes;
  public float rest_len;

  Cloth(int length, PVector anchor_start, PVector anchor_end, float rest_len) {
    this.ropes = new Rope[length];
    this.rest_len = rest_len;
    for (int i = 0; i < length; i++) {
      // vector along the same y and z plane, increasing in x by rest_len per node
      // represents the anchor node for a single "rope" section of the cloth
      PVector start_node = PVector.add(anchor_start, new PVector(rest_len*i, 0, 0));
      // represents the last node for a single "rope" section of the cloth
      PVector end_node = PVector.add(start_node, new PVector(0, 0, -1*length));
      this.ropes[i] = new Rope(length, 1, 1, start_node, end_node);
      /*
      for (int k = 0; k < length; k++) {
        println(this.ropes[i].nodes[k].pos);
      }
      */
    }
  }

  void update_physics(float t, int substeps, int relaxation_steps) {
    for(int s = 0; s < substeps; s++) {
      for (int r = 0; r < this.ropes.length; r++) {
        Rope curr_rope = this.ropes[r];
        for (int i = 0; i < curr_rope.nodes.length; i++) {
          curr_rope.nodes[i].prev_pos = new PVector(curr_rope.nodes[i].pos.x, curr_rope.nodes[i].pos.y, curr_rope.nodes[i].pos.z);
          curr_rope.nodes[i].vel.add(PVector.mult(g, t));
          curr_rope.nodes[i].pos.add(PVector.mult(curr_rope.nodes[i].vel, t));
        }
        // relax
        for (int i = 0; i < relaxation_steps; i++) {
          for (int j = 1; j < curr_rope.nodes.length; j++) {
            PVector delta = PVector.sub(curr_rope.nodes[j].pos,curr_rope.nodes[j-1].pos);
            float delta_len = delta.mag();
            float correction = delta_len - curr_rope.restLen;
            PVector delta_normalized = delta.normalize();
            curr_rope.nodes[j].pos.sub(PVector.mult(delta_normalized, correction / 2));
            curr_rope.nodes[j-1].pos.add(PVector.mult(delta_normalized, correction / 2));
          }
          curr_rope.nodes[0].pos = new PVector(curr_rope.anchor.x, curr_rope.anchor.y, curr_rope.anchor.z);
          //curr_rope.anchor = curr_rope.nodes[0].pos;
        }
        for (int i = 0; i < curr_rope.nodes.length; i++) {
          curr_rope.nodes[i].vel = PVector.mult(PVector.sub(curr_rope.nodes[i].pos, curr_rope.nodes[i].prev_pos), 1/t);
        }
      }
      for (int k = 0; k < this.ropes.length -1; k++) {
        Rope curr_rope = this.ropes[k];
        Rope next_rope = this.ropes[k+1];
        for (int i = 0; i < relaxation_steps; i++) {
          for (int j = 1; j < curr_rope.nodes.length; j++) {
            PVector delta = PVector.sub(curr_rope.nodes[j].pos,next_rope.nodes[j].pos);
            float delta_len = delta.mag();
            float correction = delta_len - curr_rope.restLen;
            PVector delta_normalized = delta.normalize();
            curr_rope.nodes[j].pos.sub(PVector.mult(delta_normalized, correction / 2));
            next_rope.nodes[j].pos.add(PVector.mult(delta_normalized, correction / 2));
          }
          curr_rope.nodes[0].pos = new PVector(curr_rope.anchor.x, curr_rope.anchor.y, curr_rope.anchor.z);
          next_rope.nodes[0].pos = new PVector(next_rope.anchor.x, next_rope.anchor.y, next_rope.anchor.z);
          //curr_rope.anchor = curr_rope.nodes[0].pos;
        }
      }
      
    }
  }
}
